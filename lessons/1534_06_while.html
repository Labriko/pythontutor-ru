{% section "Цикл while" %}
<p>Цикл <code>while</code> (&ldquo;пока&rdquo;) позволяет выполнить
одну и ту же последовательность действий, пока проверяемое условие истинно.
Условие записывается до тела цикла и проверяется до выполнения тела цикла.
Как правило, цикл <code>while</code> используется, когда невозможно
определить точное значение количества проходов исполнения цикла. 
 
<p>Синтаксис цикла <code>while</code> в простейшем случае выглядит так:
 
{% noprogram %}
while <i>условие</i>:
    блок инструкций
{% endnoprogram %}
 
<p>При выполнении цикла <code>while</code> сначала проверяется условие.
Если оно ложно, то  выполнение цикла прекращается и управление
передается на следующую инструкцию после тела цикла <code>while</code>.
Если условие истинно, то выполняется инструкция, после чего условие
проверяется снова и снова выполняется инструкция.
Так продолжается до тех пор, пока условие будет истинно.
Как только условие станет ложно, работа цикла завершится и
управление передастся следующей инструкции после цикла.
 
<p>Например, следующий фрагмент программы напечатает на экран
квадраты всех целых чисел от 1 до 10. Видно, что цикл
<code>while</code> может заменять цикл <code>for ... in range(...)</code>:
 
{% program %} 
i = 1
while i <= 10:
    print(i ** 2)
    i += 1
{% endprogram %}
 
<p>В этом примере переменная <code>i</code> внутри цикла изменяется от 1 до 10.
Такая переменная, значение которой меняется с каждым новым проходом цикла,
называется счетчиком. Заметим, что после выполнения этого фрагмента
значение переменной <code>i</code> будет равно <code>11</code>,
поскольку именно при <code>i == 11</code> условие <code>i &lt;= 10</code> впервые
перестанет выполняться.
 
 
<p>Вот еще один пример использования цикла <code>while</code> 
для определения количества цифр натурального числа <code>n</code>:
 
{% program %}
n = int(input())
length = 0
while n > 0:
    n //= 10  # это эквивалентно n = n // 10
    length += 1
print(length)
{% inputdata %}
5678
{% endinputdata %}
{% endprogram %}
 
<p>В этом цикле мы отбрасываем по одной цифре числа, начиная с конца,
что эквивалентно целочисленному делению на 10 (<code>n //= 10</code>),
при этом считаем в переменной <code>length</code>, сколько раз это было сделано.
 
<p>В языке Питон есть и другой способ решения этой задачи:
<code><nobr>length = len(str(i))</nobr></code>.
{% endsection %}

{% section "Инструкции управления циклом" %}
<p>После тела цикла можно написать слово <code>else:</code> 
и после него блок операций, который будет
выполнен <i>один раз</i> после окончания цикла, когда проверяемое
условие станет неверно:
 
{% program %}
i = 1
while i <= 10:
    print(i)
    i += 1
else:
    print('Цикл окончен, i =', i)
{% endprogram %}
 
<p>Казалось бы, никакого смысла в этом нет, ведь эту же инструкцию можно
просто написать <i>после</i> окончания цикла. Смысл появляется только
вместе с инструкцией <code>break</code>. Если во время выполнения Питон встречает 
инструкцию <code>break</code> внутри цикла, то он сразу же прекращает выполнение этого цикла и выходит из него.
При этом ветка <code>else</code> исполняться не будет. Разумеется, инструкцию <code>break</code> осмыленно
вызывать только внутри инструкции <code>if</code>, то есть она должна выполняться
только при выполнении какого-то особенного условия.

<p>Приведем пример программы, которая считывает числа до тех пор, пока не встретит 
отрицательное число. При появлении отрицательного числа программа завершается.
В первом варианте последовательность чисел завершается числом 0 (при считывании которого надо остановиться).

{% program %}
a = int(input())
while a != 0:
    if a < 0:
        print('Встретилось отрицательное число', a)
        break
    a = int(input())
else:
    print('Ни одного отрицательного числа не встретилось')

{% inputdata %}
3
6
-1
4
0
{% endinputdata %}
{% endprogram %}

Во втором варианте программы сначала на вход подается количество элементов последовательности, а затем
и сами элементы. В таком случае удобно воспользоваться циклом <code>for</code>. Цикл <code>for</code> 
также может иметь ветку <code>else</code> и содержать инструкции <code>break</code> внутри себя.

{% program %}
n = int(input())
for i in range(n):
    a = int(input())
    if a < 0:
        print('Встретилось отрицательное число', a)
        break    
else:
    print('Ни одного отрицательного числа не встретилось')

{% inputdata %}
3
6
2
4
{% endinputdata %}
{% endprogram %}

<p>Другая инструкция управления циклом&nbsp;&mdash;
<code>continue</code> (продолжение цикла).  Если эта инструкция
встречается где-то посередине цикла, то пропускаются все оставшиеся
инструкции до конца цикла, и исполнение цикла продолжается
со следующей итерации.

{% smartsnippet %}
Если инструкции <code>break</code> и <code>continue</code> содержатся внутри нескольких вложенных
циклов, то они влияют лишь на исполнение самого внутреннего цикла. Вот не самый интеллектуальный пример, 
который это демонстрирует:
{% program %}
for i in range(3):
    for j in range(5):
        if j > i:
            break
        print(i, j)
{% endprogram %}
{% endsmartsnippet %}
 
Увлечение инструкциями <code>break</code> и <code>continue</code> 
не поощряется, если можно обойтись без их использования. Вот типичный пример <i>плохого использования</i> инструкции <code>break</code> 
(данный код считает количество знаков в числе).
 
{% program %}
n = int(input())
length = 0
while True:
    length += 1
    n //= 10
    if n == 0:
        break
print('Длина числа равна', length)
{% inputdata %}
567
{% endinputdata %}
{% endprogram %}

Гораздо лучше переписать этот цикл так:
{% program %}
n = int(input())
length = 0
while n != 0:
    length += 1
    n //= 10
print('Длина числа равна', length)
{% inputdata %}
567
{% endinputdata %}
{% endprogram %}

Впрочем, на Питоне можно предложить и более изящное решение:
{% program %}
n = int(input())
print('Длина числа равна', len(str(n)))
{% inputdata %}
567
{% endinputdata %}
{% endprogram %}
{% endsection %}

{% section "Множественное присваивание" %}
В Питоне можно за одну инструкцию присваивания изменять значение сразу нескольких переменных. Делается это так:
{% noprogram %}
a, b = 0, 1
{% endnoprogram %}
Этот код можно записать и так:
{% noprogram %}
a = 0
b = 1
{% endnoprogram %}
Отличие двух способов состоит в том, что множественное присваивание в первом способе меняет значение двух переменных одновременно.

<p>Если слева от знака &laquo;=&raquo; в множественном присваивании должны стоять через запятую имена переменных, то справа могут стоять произвольные выражения, 
разделённые запятыми. Главное, чтобы слева и справа от знака присваивания было одинаковое число элементов.

<p>Множественное присваивание удобно использовать, когда нужно обменять значения двух переменных. В обычных языках
программирования без использования специальных функций это делается так:
{% program %}
a = 1
b = 2
tmp = a
a = b
b = tmp
print(a, b)  
# 2 1
{% endprogram %}

В Питоне то же действие записывается в одну строчку:
{% program %}
a = 1
b = 2
a, b = b, a
print(a, b)  
# 2 1
{% endprogram %}
{% endsection %}
